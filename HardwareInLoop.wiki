#Hardware In The Loop Simulation With the UDB and X-Plane

= 1. Overview =

The intent behind Hardware-In-the-Loop (HIL) simulation is to trick the UDB into thinking that it is flying, when it is in fact sitting stationary on your desk. If we are able to successfully do this, then we can perform any testing that we would normally do at the field (except for things like RF range tests), in the safety and comfort of your home. This should be extremely valuable for testing navigation algorithms, command languages, telemetry, wind estimation etc. The more risky a code change is, the more value there is in being able to simulate it before flight.

To allow the UDB to think it is flying, we need to replace the data that it uses to determine it's attitude - the sensor data. In this case, that means 3 axis' of acceleration, 3 axis' of rotation, and GPS data. If we can control these, then we can make the UDB think it is wherever we want, and in whatever attitude we want. To be able to do this though, we need something to generate those sensor values, and in this case we are using X-Plane, by Laminar Research. X-Plane will be responsible for accepting our control inputs, running a flight model, and then providing sensor data. Basically it becomes our airframe as far as the UDB is concerned.

The simplest part of this task is simulating the GPS data. For this, we simply acquire the appropriate data from X-Plane's datarefs, change units around to match those of the UBX protocol, and then form UBX packets. The 4 different packets that we generate are NAV_SOL, NAV_DOP, NAV_VELNED, and NAV_POSLLH. Some of the values, such as all the dilution of precision values, are just dummy values as it would be very difficult (but not impossible) to generate them, and the UDB doesn't use them anyway. Once the packets are generated, a checksum is generated, and then the packets are sent out the PC comm port at 4hz. In this setup, the PC serial port is connected to the UDB USART2 connector, in place of the GPS. I have described how i achieve this in the "hardware setup" section below.

At the same time as we are doing this, we also obtain the angular rates and accelerations of the aircraft from X-Plane. This is the basis for our simulated sensor data. Unfortunately X-Plane isn't nice enough to give us this data in the body fixed reference frame that the UDB operates in, so we have to perform several coordinate transformations, as well as compensations for centripetal acceleration. Additionally we need to perform a unit conversion from the MKS units used by X-Plane, to the odd scaled units that the UDB uses to make its values fit in an appropriate range. Once this done, we form another UBX message (which we call NAV_BODYRATES), which has made up class and id, and send that to the UDB at 50hz. Because we are using the UBX message format, the UDB as able to receive this information using the standard uBlox parsing code, with just an additional message definition added. This body rate data is double buffered in a similar manner, but separate to, the other GPS data.

At the UDB end of things, every time the rmat update routines run, rather than obtaining data from the filtered ADC variables, they take their acceleration and angular rate data from the double buffered variables from x-plane. This should be the only part of the UDB codebase that operates differently during HIL mode. All other codepaths that run in real flight should still run in our simulated mode.

So hopefully if we've done our job correctly, the UDB is none the wiser, and thinks that is flying. In response to this, it will perform it's attitude estimation and generate appropriate servo outputs to try and maintain control. We take a copy of these servo outputs, and form them into a packet with a basic checksum, which we send out of UART2 at 50hz (40hz?). If there are still servos plugged into the UDB, they will move as per normal.

Back on the PC, our HILSIM plugin receives this packet, performs a unit conversion, and writes these values into the datarefs that govern control surface deflection in X-Plane, causing the surfaces in the sim to move as commanded by the UDB.

= 2. Configuring the UDB = 

To configure the UDB, all you need do is download the branch of !MatrixPilot from https://gentlenav.googlecode.com/svn/branches/MatrixPilotHIL
This branch is based off r257 so as i write this, it is reasonably current, and most of the trunk features should work as expected. The only thing that needs to be configured at the moment, is a couple of things in options.h. The servo output values need to be set as follows:
{{{
#define THROTTLE_OUTPUT_CHANNEL   CHANNEL_3
#define AILERON_OUTPUT_CHANNEL    CHANNEL_2
#define ELEVATOR_OUTPUT_CHANNEL   CHANNEL_4
#define RUDDER_OUTPUT_CHANNEL     CHANNEL_1
}}}

and we need to make sure that we enable HIL!
{{{
#define HILSIM    1
}}}
Other than that you should be able to change options.h around to suit your setup, although i haven't tested this side of things thoroughly, so there are no guarantees!

Compile !MatrixPilot software and upload to the UDB as per normal.

= 3. Configuring X-Plane= 

The first thing you will need to do is download and install X-Plane. A demo version is freely available, with the limitation that you can only fly for 10 minutes before it locks the joystick out. Fortunately for us, we bypass the joystick interface, so we can continue to fly after the 10 mins is up, albeit with a dialog box over the middle of the screen. If you find X-Plane to be useful, either for this HIL stuff, or just as a flight sim, the full version is only $29USD, and includes 7 or 8 DVDs worth of scenery for the whole globe.

When you start X-Plane for the first time, i recommend setting up a hotkey to reset your aircraft to the runway. This will come in handy when you need the plane sitting still on the ground in order to reinitialise the UDB, without having to navigate the menus. Go to the "Settings" menu, and select "Joystick, Keys & Equipment". Select the "Keys" tab. Click on the "Add New Key Assignment" button. Select the new item labeled `<NONE>` at the bottom of the key assignment list. Press the key combo you would like to assign, in my case i used CTRL + R. In the middle pane select the "operation/" radio button, and then in the right hand pane, select "reset_to_runway". Your screen should look like the one below.

<a href="http://picasaweb.google.com.au/lh/photo/-XteTSZ-SMxWHtVct8NHLQ?authkey=Gv1sRgCIC3lZTg9_CSdg&feat=embedwebsite"><img src="http://lh5.ggpht.com/_GufzRAf4Eas/S2gq_BE49-I/AAAAAAAAAIY/rfNqB5JPRgw/s800/XPlaneHotkey.jpg" /></a>

(If you have limited scenery, either because you have the demo version of X-Plane, or because you just haven't got around to installing it, you may want to select "go_to_default" instead of "reset_to_runway", to return you to the default airport and runway. The "reset_to_runway" command will just reset to the nearest runway, and with no scenery installed you can spend a lot of time flying out of airfields in the middle of the ocean :)

If you are planning to do any development on the X-Plane plugin at all (and at the moment you *will* be, because of things that are hard coded into it :) you will also want the "reload plugins" plugin, that allows you to reload your plugins without having to restart X-Plane, which is a *HUGE* timesaver. The precompiled plugin is available as part of the X-Plane SDK examples available here: http://www.xsquawkbox.net/xpsdk/mediawiki/SDK_Example_Binaries

Place the !ReloadPlugins.xpl file into your Plugins directory, which will be located in `[XPLANE_ROOT]\Resources\Plugins`. For example, on my demo install of X-Plane 9, the path to the plugins directory is "C:\Program Files\X-Plane 9 Demo\Resources\plugins".

The next step is to download and compile our HIL plugin. The plugin source lives in SVN, it's path is https://gentlenav.googlecode.com/svn/trunk/Tools/XP_UDB_HILSIM

Check out the code using an SVN client such as tortise SVN, exactly as you would if you were checking out the UDB firmware.

The code is in the form a Visual Studio 2008 solution. You can probably compile the code under something else, but you need to be able to set it up to create the correct type of file for an x-plane plugin, which i think is pretty much a DLL. Anyway, use other compilers at your peril, i have only ever used Visual Studio (which is freely available in express editions) and can offer no support or advice on anything else.

The basic development workflow is as follows:

 # Modify code in Visual Studio
 # Compile and check for errors and warnings
 # Once you have a clean build, copy the plugin file (HILSIM.xpl, located in the \Debug folder of the solution) to the X-Plane plugins folder, `[XPLANE_ROOT]\Resources\Plugins`. 
 # If X-Plane is already running, you will need to unload the plugins first, by going to the "Plugins" menu, and selecting "!ReloadPlugins" and then "Reload". You should be presented with the following dialog box:

<a href="http://picasaweb.google.com.au/lh/photo/8Rdw76FemGvneSacjGlQSA?authkey=Gv1sRgCIC3lZTg9_CSdg&feat=embedwebsite"><img src="http://lh5.ggpht.com/_GufzRAf4Eas/S2gq_IOopXI/AAAAAAAAAIU/dl81uvkhRNE/s800/ReloadPlugins.jpg" /></a>

Copy your plugin to the plugin folder *first*, and then return to X-Plane and click "Understood". This will reload all of the installed plugins.
 # If X-Plane is already running and you *didn't* install the !ReloadPlugins plugin, you will have to exit from X-Plane, copy your plugin across, and then restart X-Plane.
 # Test plugin in X-Plane.
 # Repeat as necessary :)

The main thing that you will need to change to get the plugin working under your environment, is the name of the serial port you wish to use. In the file HILSIM.cpp file, within the !OpenComms function there is the following line (located at [http://code.google.com/p/gentlenav/source/browse/trunk/Tools/XP_UDB_HILSIM/HILSIM.cpp#560 line 560] in r262):
{{{
char *PortString = "\\\\.\\COM4";
}}}
You will need to change COM4 to match whatever your serial port is set to. This format (with all those crazy slashes) should work fine for any comm port (ie it's not limited to ports <= 4 like lots of things seem to be.

Once you have compiled the plugin with the correct comm port, and copied it into the plugin directory as described above, you should be right to go as far as the PC side of things is concerned.


= 4. Hardware Setup = 
All of the HIL communication is performed through USART2 on the UDB, which is normally the GPS port. We need to connect this port to a serial port on the PC. In most cases, a USB serial port board such as one of the variety of FTDI boards available from Sparkfun is the easiest way to achieve this. To make the connection at the UDB end, I have used the Diydrones uBlox adapter as a pin adapter with the standard 6 pin em406 cable. If you do not have one of these adapters, then you may need to rig something up, perhaps by splicing extra wires into your GPS cable.
Connecting the FTDI board to the uBlox adapter is slightly counter intuitive (i found), but if you get it wrong the symptoms are obvious, as nothing will work :) The connections are as follows:

 * FTDI TX -> "OUT" pin on uBlox adapter, which is the RX pin on the UDB UART.
 * FTDI RX -> "IN" pin on uBlox adapter, which is the TX pin on the UDB UART.
 * FTDI GND -> "GND" pin on adapter, or GND anywhere on the UDB.

= 5. Using the Hardware-In-Loop simulator. =

To get the simulator running, follow these steps:

 # Connect hardware as described above.
 # Start X-Plane, after ensuring that the HILSIM plugin is in the correct directory. Either switch to an external view ("a" key by default) and/or turn on the control surface graph by going the the "Special" menu, and selecting "Show Control Deflections".
 # Turn on the dev board.
 # Once the dev board recognises the RC receiver, you should be able to control the control surfaces of the plane. After the normal startup period, the rudder and ailerons should wag, indicating GPS lock.
 # When the HILSIM plugin starts the throttle is set at 0, so depending on the plane, the engine might have stopped before the UDB started sending actual throttle values. If this is the case, reset the plane, using the hotkey setup earlier (CTRL-R if you followed my lead).
 # Fly your plane like its a real one! Or more importantly help me work out why the sensor values aren't quite right yet